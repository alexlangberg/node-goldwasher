<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: goldwasher.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: goldwasher.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// jscs:disable requirePaddingNewLinesAfterBlocks
// jscs:disable requireCamelCaseOrUpperCaseIdentifiers
'use strict';

var v = require('validator');
var S = require('string');
var R = require('ramda');
var Joi = require('joi');
var cheerio = require('cheerio');
var uuid = require('node-uuid');
var js2xmlparser = require('js2xmlparser');
var Feed = require('feed');
var NodePie = require('nodepie');
var xml2json = require('xml2json');

/**
 * Gets an object with the default options.
 * @returns {{
 *  filterKeywords: Array,
 *  filterLocale: boolean,
 *  filterTexts: Array,
 *  limit: null,
 *  output: string,
 *  search: Array,
 *  selector: string,
 *  url: null
 *}}
 */
var getDefaultOptions = function() {
  return {
    filterKeywords: [],
    filterLocale: false,
    filterTexts: [],
    limit: null,
    output: 'json',
    search: [],
    selector: 'h1, h2, h3, h4, h5, h6, p',
    url: null
  };
};

/**
 * Gets the validation schema for Joi.
 * @returns {*|Array}
 */
var getOptionsSchema = function() {
  return Joi.object().keys({
    filterKeywords: Joi.array(),
    filterLocale: Joi.string().valid('en'),
    filterTexts: Joi.array(),
    limit: Joi.number().integer(),
    output: Joi.string().valid('json', 'xml', 'atom', 'rss'),
    search: Joi.array(),
    selector: Joi.string(),
    url: Joi.string()
  });
};

/**
 * Validates options passed by the user and merges them with defaults
 * @param options
 * @returns {Object|*}
 */
var getOptions = function(options) {
  // create default options object if none is provided or test schema
  if (options === undefined) {
    options = {};
  } else {
    Joi.validate(options, getOptionsSchema(), function(error) {
      if (error) {
        throw error;
      }
    });
  }

  // overwrite default options if options object is provided
  return R.merge(getDefaultOptions(), options);
};

/**
 * Finds the closest &lt;a> tag and returns the HREF of it.
 * Also converts relative URLs to absolute.
 * @param domObject
 * @param url
 * @returns {*}
 */
var getCheerioClosestHref = function(domObject, url) {
  var href = null;

  // has HREF itself
  if (domObject[0].name &amp;&amp; domObject[0].name === 'a') {
    href = domObject.attr('href');
  }

  // child node that has a HREF
  else if (domObject.children('a').length > 0) {
    href = domObject.children('a').attr('href');
  }

  // parent that has a HREF
  else if (domObject.closest('a').length > 0) {
    href = domObject.closest('a').attr('href');
  }

  // adjecent node that has a HREF
  else if (domObject.next('a').length > 0) {
    href = domObject.next('a').attr('href');
  }

  // check for relative URLs and append URL if relative
  if (url &amp;&amp; href &amp;&amp; !v.isURL(href)) {
    href = url + href;
  }

  if (!href) { return url; }

  return href;
};

/**
 * Gets the text of a cheerio DOM object.
 * @param text
 * @returns {String.s|*}
 */
var sanitizeText = function(text) {
  return S(text)
    .unescapeHTML()
    .stripTags()
    .collapseWhitespace()
    .trim()
    .s;
};

/**
 * Gets the contant of a meta tag.
 * @param $
 * @param name
 * @returns {*|string|String|jQuery}
 */
var getCheerioMetaTag = function($, name) {
  return $('meta').filter(function() {
    return $(this).attr('name') === name;
  }).map(function() {
    return $(this).attr('content');
  }).get().join();
};

/**
 * Returns a slugified version of the text or an array of texts.
 * Often used for comparison.
 * @param text
 * @returns {*}
 */
var slugifyText = function(text) {
  if (R.isArrayLike(text)) {
    return R.map(slugifyText, text);
  }
  return S(text).slugify().s;
};

/**
 * Checks whether a list contains provided text.
 * @param text
 * @param list
 * @returns {boolean}
 */
var slugifiedTextArrayContains = function(text, list) {
  return !!R.contains(slugifyText(text), slugifyText(list));
};

/**
 * Checks whether a text contains any text in a list
 * @param text
 * @param list
 * @returns {boolean}
 */
var slugifiedTextContains = function(text, list) {
  return !!R.filter(function(listItem) {
    return S(slugifyText(text)).contains(slugifyText(listItem));
  }, list).length;
};

/**
 * Reversed slugifiedTextArrayContains.
 * @param text
 * @param blacklist
 * @returns {boolean}
 */
var slugifiedTextFilter = function(text, blacklist) {
  return !slugifiedTextArrayContains(text, blacklist);
};

/**
 * * Returns array of keywords not in the blacklist.
 * @param keywords
 * @param blacklist
 * @returns {Array|*}
 */
var filterKeywords = function(keywords, blacklist) {
  return R.filter(function(item) {
    return slugifiedTextFilter(item, blacklist);
  }, keywords);
};

/**
 * Counts keyword occurences in text.
 * @param text
 * @param keywords
 * @returns {Array|*}
 */
var countKeywords = function(text, keywords) {
  return R.map(function(keyword) {
    return {
      word: keyword,
      count: S(text).slugify().count(keyword)
    };
  }, keywords);
};

/**
 * Get keywords from text.
 * @param text
 * @param blacklist
 * @returns {Array|*}
 */
var getKeywordsFromText = function(text, blacklist) {
  var keywords = R.uniq(slugifyText(text).split('-'));

  return countKeywords(text, filterKeywords(keywords, blacklist));
};

/**
 * Get meta data from cheerio for building feeds.
 * @param $
 * @param url
 * @returns {{
 *  author: (*|string|String|jQuery),
 *  description: (*|string|String|jQuery),
 *  url: *,
 *  time: (number|*),
 *  title: (String.s|*)
 *}}
 */
var getCheerioMeta = function($, url) {
  return {
    author: getCheerioMetaTag($, 'author'),
    description: getCheerioMetaTag($, 'description'),
    url: url,
    time: Date.now(),
    title: sanitizeText($('title').text())
  };
};

/**
 * Get meta data from nuggets for building feeds.
 * @param nuggets
 * @returns {{
 *   url: (convertLcovFileObject.source|*|ret.source|source|string|Window),
 *   time: (timestamp|*|Number|number)
 * }}
 */
var getNuggetsMeta = function(nuggets) {
  return {
    url: nuggets[0].source,
    time: nuggets[0].timestamp
  };
};

/**
 * Get all keywords from an array of nuggets.
 * @type {Function|*}
 */
var getNuggetsKeywordTexts = R.pipe(
  R.map(function(nugget) {
    return nugget.keywords;
  }),
  R.flatten(),
  R.map(function(keyword) {
    return keyword.word;
  }),
  R.uniq()
);

/**
 * Converts a batch of nuggets to a string of XML.
 * @param batch
 * @returns {*}
 */
var outputToXml = function(batch) {
  var nuggets = R.forEach(function(nugget) {
    nugget.keyword = nugget.keywords;
    delete nugget.keywords;
  }, batch.nuggets);

  return js2xmlparser('goldwasher', {nugget: nuggets});
};

/**
 * Converts an array of nuggets to a feed.
 * @param batch
 * @param output
 * @returns {*}
 */
var outputToFeed = function(batch, output) {
  var feed = new Feed({
    description: batch.meta.description,
    link: batch.meta.url,
    title: batch.meta.title
  });

  R.forEach(function(keyword) {
    feed.addCategory(keyword);
  }, getNuggetsKeywordTexts(batch.nuggets));

  R.forEach(function(nugget) {
    feed.addItem({
      author: [{
        name: batch.meta.author,
        link: batch.meta.url
      }],
      date: new Date(),
      description: nugget.text,
      guid: nugget.href,
      link: nugget.href,
      title: nugget.text
    });
  }, batch.nuggets);

  return feed.render(output);
};

/**
 * Function to get keywords for a nugget from a text.
 * @param text
 * @param filterKeywords
 * @param filterLocale
 * @returns {Array|*}
 */
var getNuggetKeywords = function(text, filterKeywords, filterLocale) {
  var stopwords = filterKeywords;
  var localeJson;

  if (filterLocale) {
    localeJson = require(
      '../stop_words/' + filterLocale + '.json'
    );
    stopwords = R.concat(stopwords, localeJson.stopWords);
  }

  return getKeywordsFromText(text, stopwords);
};

/**
 * Determine if a nugget should be filtered out according to options.
 * @param text
 * @param index
 * @param options
 * @returns {boolean}
 */
var nuggetFilter = function(text, index, options) {
  if (options.limit &amp;&amp; index >= options.limit) {
    return true;
  }

  if (slugifiedTextArrayContains(text, options.filterTexts)) {
    return true;
  }

  if (options.search.length > 0) {
    if (!slugifiedTextContains(text, options.search)) {
      return true;
    }
  }
};

/**
 * Converts a cheerio object to a batch of nuggets.
 * @param $
 * @param options
 * @returns {{
 *   meta: {
 *     author: (*|string|String|jQuery),
 *     description: (*|string|String|jQuery),
 *     url: *,
 *     time: (number|*),
 *     title: (String.s|*)},
 *   nuggets: Array
 * }}
 */
var inputFromCheerio = function($, options) {
  var meta = getCheerioMeta($, options.url);
  var scraped = $(options.selector);
  var nuggets = [];
  var batchUuid = uuid.v1();

  scraped.each(function(index) {
    var nugget = {};
    var text = sanitizeText($(this).text());

    if (nuggetFilter(text, index, options)) { return; }

    nugget.source = options.url;
    nugget.href = getCheerioClosestHref($(this), options.url);
    nugget.tag = $(this)[0].name;
    nugget.text = text;
    nugget.position = index;
    nugget.timestamp = meta.time;
    nugget.uuid = uuid.v1();
    nugget.batch = batchUuid;
    nugget.keywords = getNuggetKeywords(
      text,
      options.filterKeywords,
      options.filterLocale
    );

    nuggets.push(nugget);
  });

  nuggets = R.forEach(function(nugget) {
    nugget.total = nuggets.length;
  }, nuggets);

  return {
    meta: meta,
    nuggets: nuggets
  };
};

/**
 * Get meta data for building feeds.
 * @param feed
 * @returns {{description: *, url: *, time: (number|*), title: *}}
 */
var getFeedMeta = function(feed) {
  return {
    description: feed.getDescription(),
    url: feed.getPermalink(),
    time: Date.now(),
    title: feed.getTitle()
  };
};

/**
 * Converts a NodePie object to an array of nuggets.
 * @param input
 * @param options
 * @returns {{
 *   meta: {
 *     description: *,
 *     url: *,
 *     time: (number|*),
 *     title: *
 *   },
 *   nuggets: Array
 * }}
 */
var inputFromFeed = function(input, options) {
  var feed = new NodePie(input);
  feed.init();
  var meta = getFeedMeta(feed);
  var scraped = feed.getItems(0);
  var nuggets = [];
  var batchUuid = uuid.v1();

  R.forEachIndexed(function(value, index) {
    var nugget = {};
    var text = sanitizeText(value.getTitle());

    if (nuggetFilter(text, index, options)) { return; }

    nugget.source = meta.url;
    nugget.href = feed.getPermalink();
    nugget.tag = 'feed';
    nugget.text = text;
    nugget.position = index;
    nugget.timestamp = meta.time;
    nugget.uuid = uuid.v1();
    nugget.batch = batchUuid;
    nugget.keywords = getNuggetKeywords(
      text,
      options.filterKeywords,
      options.filterLocale
    );
    nuggets.push(nugget);
  }, scraped);

  nuggets = R.forEach(function(nugget) {
    nugget.total = nuggets.length;
  }, nuggets);

  return {
    meta: meta,
    nuggets: nuggets
  };
};

/**
 * Detects the type of input. Could be improved a lot.
 * @param input
 * @returns {string}
 */
var detectInputType = function(input) {
  if (R.is(String, input)) {

    // detect RSS for NodePie
    if (S(input).contains('&lt;feed xmlns="http://www.w3.org/2005/Atom">') ||
        S(input).contains('&lt;rss version="2.0">') ||
        S(input).contains('&lt;rss version="0.92">') ||
        S(input).contains('&lt;/rdf:RDF>')) {
      return 'feed';
    }

    // detect if goldwasher XML format
    if (S(input).contains('&lt;goldwasher>')) {
      return 'goldwasherXml';
    }

    // detect if XML
    if (S(input).contains('&lt;?xml version="1.0" encoding="UTF-8"?>')) {
      return 'xml';
    }

    // detect if HTML. Lamest detector ever? Pretty much the default anyway.
    if (S(input).contains('&lt;')) {
      return 'html';
    }

    throw new Error('Could not determine input type. (string)');
  } else {

    //if input is not string, it must be a goldwasher array or cheerio object
    if (R.has('parseHTML', input)) {
      return 'cheerio';
    }

    if (R.isArrayLike(input)) {
      if (R.has('timestamp', input[0])) {
        return 'array';
      }
    }

    throw new Error('Could not determine input type. (cheerio/array)');
  }
};

/**
 * Converts a nugget from XML format to JSON format
 * @param nugget
 * @returns {*}
 */
var xmlNuggetToJsonNugget = function(nugget) {
  nugget.keywords = [nugget.keyword];
  delete nugget.keyword;
  return nugget;
};

/**
 * Converts goldwasher XML to nuggets.
 * @param input
 * @returns {{
 *   meta: {
 *     url: (convertLcovFileObject.source|*|ret.source|source|string|Window),
 *     time: (timestamp|*|Number|number)
 *   },
 *   nuggets: *
 * }}
 */
var inputFromGoldwasherXml = function(input) {
  var json = xml2json.toJson(input, {object: true});
  var nuggets;

  if (R.isArrayLike(json.goldwasher.nugget)) {
    nuggets = R.map(function(nugget) {
      return xmlNuggetToJsonNugget(nugget);
    }, json.goldwasher.nugget);
  } else {
    nuggets = [xmlNuggetToJsonNugget(json.goldwasher.nugget)];
  }

  return {
    meta: getNuggetsMeta(nuggets),
    nuggets: nuggets
  };
};

/**
 * Receives html as string or cheerio DOM, along with optional options object.
 * Outputs an array of objects in goldwasher output.
 * @param input
 * @param userOptions
 * @returns {*}
 */
var goldwasher = function(input, userOptions) {
  var batch;
  var options = getOptions(userOptions);
  options.input = detectInputType(input);

  // first we get the batch of nuggets and meta data
  if (options.input === 'array') {
    batch = {
      meta: getNuggetsMeta(input),
      nuggets: input
    };
  }

  if (options.input === 'cheerio' ||
      options.input === 'html' ||
      options.input === 'xml') {

    if (options.input !== 'cheerio') {
      batch = inputFromCheerio(cheerio.load(input), options);
    } else {
      batch = inputFromCheerio(input, options);
    }
  }

  if (options.input === 'feed') {
    batch = inputFromFeed(input, options);
  }

  if (options.input === 'goldwasherXml') {
    batch = inputFromGoldwasherXml(input);
  }

  // now that we have the batch of nuggets, determine how to output them
  if (options.output === 'xml') {
    return outputToXml(batch);
  }

  if (options.output === 'atom') {
    return outputToFeed(batch, 'atom-1.0');
  }

  if (options.output === 'rss') {
    return outputToFeed(batch, 'rss-2.0');
  }

  // else default to json
  return batch.nuggets;
};

module.exports = goldwasher;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Thu May 14 2015 14:59:49 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
